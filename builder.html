<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Piece TCG Deck Builder</title>
    <link rel="icon" href="favicon.png" type="image/png">
    <style>
        :root {
            --bg-color: #f5f5ff;
            --surface-color: #ffffff;
            --text-color: #333;
            --primary-color: #1976d2;
            --border-color: #ddd;
            --shadow-color: rgba(0,0,0,0.1);
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        .container {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            max-width: 1800px;
            width: 100%;
            margin: 0 auto;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .main-nav { background-color: var(--surface-color); border-radius: 8px; box-shadow: 0 2px 4px var(--shadow-color); margin-bottom: 20px; padding: 10px 0px; width: 100%; box-sizing: border-box; }
        .main-nav ul { list-style: none; margin: 0; padding: 0; display: flex; justify-content: flex-start; }
        .main-nav li a { text-decoration: none; color: var(--text-color); font-weight: bold; font-size: 16px; padding: 10px 15px; border-radius: 6px; transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; }
        .main-nav li a:hover, .main-nav li a.active { background-color: #e3f2fd; color: var(--primary-color); }

        .deck-builder-layout { display: flex; gap: 20px; flex-grow: 1; overflow: hidden; }
        .card-pool-column { flex: 2; display: flex; flex-direction: column; min-width: 0; }
        .deck-area-column { flex: 2.5; display: flex; flex-direction: column; height: calc(100vh - 100px); position: sticky; top: 20px; }

        .controls { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
        .search-bar { width: 100%; padding: 12px; font-size: 16px; border: 1px solid var(--border-color); border-radius: 8px; box-sizing: border-box; }
        
        .filters-container { display: flex; flex-direction: column; gap: 10px; }
        .filters-row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
        .filter-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; padding: 4px 8px; background: rgba(0,0,0,0.02); border-radius: 6px; border: 1px solid #eee;}

        .filter-chip {
            width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center; box-sizing: border-box; font-size: 11px; font-weight: bold;
            color: white; text-shadow: 1px 1px 1px rgba(0,0,0,0.5);
        }
        .filter-chip:hover { transform: scale(1.05); }
        .filter-chip.active { border-color: #333; box-shadow: 0 0 0 1px #fff, 0 0 0 3px #333; transform: scale(1.1); }
        .color-chip.red { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .color-chip.green { background: linear-gradient(135deg, #27ae60, #2ecc71); }
        .color-chip.blue { background: linear-gradient(135deg, #3498db, #2980b9); }
        .color-chip.purple { background: linear-gradient(135deg, #9b59b6, #8e44ad); }
        .color-chip.black { background: linear-gradient(135deg, #34495e, #2c3e50); }
        .color-chip.yellow { background: linear-gradient(135deg, #f1c40f, #f39c12); }
        .cost-chip { background: linear-gradient(135deg, #6c757d, #495057); }
        .type-chip { background: linear-gradient(135deg, #17a2b8, #117a8b); }
        .counter-chip { background: linear-gradient(135deg, #ffc107, #e0a800); }
        .property-chip { background: linear-gradient(135deg, #6c757d, #495057); width: auto; height: 26px; padding: 0 10px; border-radius: 13px; }
        .property-chip.active { background: linear-gradient(135deg, #28a745, #218838); border-color: #155724; }
        .property-chip.inverse { background: linear-gradient(135deg, #dc3545, #c82333); border-color: #721c24; }
        
        .cards-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; overflow-y: auto; flex-grow: 1; padding-right: 10px; }
        .card-item { cursor: pointer; transition: transform 0.2s; position: relative; }
        .card-item:hover { transform: scale(1.03); }
        .card-item img { width: 100%; height: auto; border-radius: 6px; display: block; }
        .card-item .no-image { width: 100%; aspect-ratio: 0.71; background: #f0f0f0; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 12px; color: #999; text-align: center; }

        .deck-area-content { background: var(--surface-color); border-radius: 8px; box-shadow: 0 2px 4px var(--shadow-color); display: flex; flex-direction: column; flex-grow: 1; overflow: hidden; }
        .deck-header { padding: 15px; border-bottom: 1px solid var(--border-color); }
        .leader-slot { display: flex; align-items: center; gap: 15px; }
        .leader-image { width: 100px; height: 140px; border-radius: 6px; background: #f0f0f0; border: 2px dashed var(--border-color); display: flex; align-items: center; justify-content: center; font-size: 12px; color: #999; flex-shrink: 0; overflow: hidden; }
        .leader-image img { width: 100%; height: 100%; object-fit: cover; }
        
        .leader-info { display: flex; flex-direction: row; flex-grow: 1; justify-content: space-between; align-items: center; }
        .deck-type-stats { font-size: 14px; font-weight: bold; line-height: 1.6; }
        .deck-actions { display: flex; flex-direction: column; gap: 8px; align-items: stretch; }
        .deck-btn { padding: 8px 12px; text-align: center; border-radius: 6px; border: 1px solid var(--border-color); background: #f9f9f9; cursor: pointer; font-size: 12px; transition: background-color 0.2s; }
        .deck-btn:hover { background: #f0f0f0; }
        .deck-btn.primary { background: var(--primary-color); color: white; border-color: var(--primary-color); }

        .deck-list-container { overflow-y: auto; flex-grow: 1; padding: 15px; }
        .deck-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 12px; }
        .deck-grid-card { position: relative; cursor: pointer; aspect-ratio: 0.714; transition: transform 0.1s ease-out; }
        .deck-grid-card:hover { transform: scale(1.05); }
        .deck-grid-card img { width: 100%; height: 100%; border-radius: 5px; display: block; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        .card-quantity-badge {
            position: absolute; bottom: -5px; right: -5px; background-color: rgba(25, 118, 210, 0.95);
            color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;
            font-size: 12px; font-weight: bold; border: 2px solid white; pointer-events: none;
        }
        
        .deck-footer { padding: 15px; border-top: 1px solid var(--border-color); background: #f8f9fa; }
        .deck-stats { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; font-size: 14px; font-weight: bold; }
        .cost-curve-container { display: flex; gap: 4px; align-items: flex-end; height: 60px; }
        .cost-bar { flex: 1; background: var(--primary-color); border-radius: 3px 3px 0 0; position: relative; display: flex; flex-direction: column-reverse; align-items: center; }
        .cost-label { font-size: 10px; font-weight: bold; color: #666; text-align: center; }
        .cost-bar .bar-count { font-size: 10px; color: white; font-weight: bold; position: absolute; top: 2px; }
        .status { padding: 20px; text-align: center; font-weight: bold; }
        
        .searcher-analysis { margin-top: 20px; }
        .searcher-analysis h3 { font-size: 16px; margin-bottom: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }
        .searcher-item { display: flex; gap: 15px; margin-bottom: 15px; align-items: flex-start; }
        .searcher-image { width: 75px; flex-shrink: 0; }
        .searcher-image img { width: 100%; height: auto; border-radius: 5px; }
        .searcher-table-container { flex-grow: 1; }
        .searcher-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .searcher-table th, .searcher-table td { border: 1px solid var(--border-color); padding: 4px; text-align: center; }
        .searcher-table th { background-color: #f2f2f2; font-weight: bold; }
        .searcher-info { font-size: 12px; margin-bottom: 5px; }
        .searcher-info strong { color: var(--primary-color); }
    </style>
</head>
<body>
    <div class="container">
        <nav class="main-nav">
            <ul>
                <li><a href="index.html">Database</a></li>
                <li><a href="stats.html">Statistics</a></li>
                <li><a href="deck-builder.html" class="active">Deck Builder</a></li>
            </ul>
        </nav>

        <div class="deck-builder-layout">
            <div class="card-pool-column">
                <div class="controls">
                    <input type="text" id="searchBar" class="search-bar" placeholder="Search cards by name, type, color, or effect...">
                     <div class="filters-container">
                        <div class="filters-row">
                            <div class="filter-group color-filter">
                                <div class="filter-chip color-chip red" data-color="Red"></div>
                                <div class="filter-chip color-chip green" data-color="Green"></div>
                                <div class="filter-chip color-chip blue" data-color="Blue"></div>
                                <div class="filter-chip color-chip purple" data-color="Purple"></div>
                                <div class="filter-chip color-chip black" data-color="Black"></div>
                                <div class="filter-chip color-chip yellow" data-color="Yellow"></div>
                            </div>
                            <div class="filter-group type-filter">
                                <div class="filter-chip type-chip" data-type="LEADER">L</div>
                                <div class="filter-chip type-chip" data-type="CHARACTER">C</div>
                                <div class="filter-chip type-chip" data-type="EVENT">E</div>
                                <div class="filter-chip type-chip" data-type="STAGE">S</div>
                            </div>
                            <div class="filter-group counter-filter">
                                <div class="filter-chip counter-chip" data-counter="0">0k</div>
                                <div class="filter-chip counter-chip" data-counter="1000">1k</div>
                                <div class="filter-chip counter-chip" data-counter="2000">2k</div>
                            </div>
                        </div>
                        <div class="filters-row">
                            <div class="filter-group property-filter">
                                <div class="filter-chip property-chip" data-property="effect">Effect</div>
                                <div class="filter-chip property-chip" data-property="on_play">On Play</div>
                                <div class="filter-chip property-chip" data-property="trigger">Trigger</div>
                                <div class="filter-chip property-chip" data-property="when_attacking">W/ ATK</div>
                                <div class="filter-chip property-chip" data-property="blocker">Blocker</div>
                            </div>
                             <div class="filter-group cost-filter">
                                <div class="filter-chip cost-chip" data-cost="0">0</div>
                                <div class="filter-chip cost-chip" data-cost="1">1</div>
                                <div class="filter-chip cost-chip" data-cost="2">2</div>
                                <div class="filter-chip cost-chip" data-cost="3">3</div>
                                <div class="filter-chip cost-chip" data-cost="4">4</div>
                                <div class="filter-chip cost-chip" data-cost="5">5</div>
                                <div class="filter-chip cost-chip" data-cost="6">6</div>
                                <div class="filter-chip cost-chip" data-cost="7">7</div>
                                <div class="filter-chip cost-chip" data-cost="8">8</div>
                                <div class="filter-chip cost-chip" data-cost="9">9</div>
                                <div class="filter-chip cost-chip" data-cost="10">10</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div id="cardsContainer" class="cards-grid">
                    <div id="status" class="status">Loading cards...</div>
                </div>
            </div>

            <div class="deck-area-column">
                <div class="deck-area-content">
                    <div class="deck-header">
                        <div class="leader-slot">
                            <div id="leaderImage" class="leader-image">LEADER</div>
                            <div class="leader-info">
                                <div class="deck-type-stats">
                                    <div>Characters: <span id="characterCount">0</span></div>
                                    <div>Events: <span id="eventCount">0</span></div>
                                    <div>Stages: <span id="stageCount">0</span></div>
                                </div>
                                <div class="deck-actions">
                                    <button class="deck-btn" title="Functionality coming soon!">Export</button>
                                    <button class="deck-btn primary" id="clearDeckBtn">Clear Deck</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="deckListContainer" class="deck-list-container">
                        <div id="deckGrid" class="deck-grid"></div>
                        <div id="searcherAnalysis" class="searcher-analysis"></div>
                    </div>
                    <div class="deck-footer">
                        <div class="deck-stats">
                            <div id="deckCardCount">Total Cards: 0 / 50</div>
                        </div>
                        <div class="cost-curve-container" id="costCurve"></div>
                        <div id="costCurve-labels" class="cost-curve-labels" style="display: flex; gap: 4px; margin-top: 4px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let allCards = [];
        let deck = new Map();
        let leader = null;

        const DECK_SIZE = 50;
        const MAX_COPIES = 4;
        let selectedColors = new Set(), selectedCosts = new Set(), selectedTypes = new Set(), selectedCounters = new Set(), propertyFilterStates = new Map();

        async function initializeDeckBuilder() {
            await loadCards();
            setupEventListeners();
            updateDeckView();
        }

        async function loadCards() {
            try {
                const response = await fetch('/api/get-cards');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                allCards = data.data.map(c => ({
                    id: c[0] || 'N/A', cardType: c[3] || 'N/A', name: c[4] || 'N/A',
                    cost: (c[5] !== null && c[5] !== undefined) ? parseInt(c[5]) : null,
                    power: c[7], counter: c[8], color: c[9] || 'N/A', type: c[10] || '', effect: c[11] || '', trigger: c[14]
                })).filter(card => card.name && card.name.trim() !== '' && !card.id.includes('_'));
                document.getElementById('status').style.display = 'none';
                applyFilters();
            } catch (error) {
                console.error('Error loading cards:', error);
                document.getElementById('status').textContent = `Failed to load cards: ${error.message}`;
            }
        }

        function applyFilters() {
            const searchTerm = document.getElementById('searchBar').value.toLowerCase();
            const filtered = allCards.filter(card => {
                const s = (txt) => txt && txt.toLowerCase().includes(searchTerm);
                if (!s(card.name) && !s(card.effect)) return false;
                if (selectedColors.size > 0 && !Array.from(selectedColors).some(c => card.color?.includes(c))) return false;
                if (selectedCosts.size > 0 && !(card.cardType !== 'LEADER' && selectedCosts.has(String(card.cost)))) return false;
                if (selectedTypes.size > 0 && !selectedTypes.has(card.cardType)) return false;
                if (selectedCounters.size > 0 && !(card.cardType === 'CHARACTER' && selectedCounters.has(String(card.counter ?? 0)))) return false;
                for (const [prop, state] of propertyFilterStates.entries()) {
                    const effectText = card.effect.toLowerCase();
                    const propertyExists = {
                        effect: card.effect.trim() !== '', on_play: effectText.includes('[on play]'),
                        trigger: card.trigger && card.trigger.trim() !== '', when_attacking: effectText.includes('[when attacking]'),
                        blocker: effectText.includes('[blocker]')
                    }[prop];
                    if ((state === 'has' && !propertyExists) || (state === 'no' && propertyExists)) return false;
                }
                if (leader && card.cardType !== 'LEADER' && !leader.color.split('/').some(lc => card.color?.includes(lc))) return false;
                return true;
            });
            renderCardPool(filtered);
        }

        function renderCardPool(cards) {
            const container = document.getElementById('cardsContainer');
            container.innerHTML = cards.length === 0 ? `<div class="status">No cards match your filters.</div>` :
                cards.slice(0, 100).map(card => {
                    const imagePath = getImagePath(card);
                    return `<div class="card-item" data-card-id="${card.id}">
                        ${imagePath ? `<img src="${imagePath}" alt="${card.name}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=&quot;no-image&quot;>${card.name}</div>'">` : `<div class="no-image">${card.name}</div>`}
                    </div>`;
                }).join('');
        }
        
        function getImagePath(card) {
            let setName = card.id.startsWith('P-') ? 'P' : card.id.match(/^([A-Z]+\d+)/)?.[1];
            return setName ? `Cards/${setName}/${card.id}.webp` : null;
        }

        function handleCardClick(event) {
            const cardId = event.target.closest('.card-item')?.dataset.cardId;
            if (!cardId) return;
            const card = allCards.find(c => c.id === cardId);
            if (!card) return;
            card.cardType === 'LEADER' ? setLeader(card) : addCardToDeck(card);
        }

        function setLeader(newLeader) {
            leader = (leader?.id === newLeader.id) ? null : newLeader;
            validateDeckColors();
            applyFilters();
            updateDeckView();
        }

        function addCardToDeck(card) {
            const currentCount = deck.get(card.id) || 0;
            const totalDeckSize = Array.from(deck.values()).reduce((sum, count) => sum + count, 0);
            if (totalDeckSize < DECK_SIZE && currentCount < MAX_COPIES) {
                deck.set(card.id, currentCount + 1);
                updateDeckView();
            }
        }

        function changeCardQuantity(cardId, change) {
            const newCount = (deck.get(cardId) || 0) + change;
            if (newCount <= 0) deck.delete(cardId);
            else if (newCount <= MAX_COPIES) deck.set(cardId, newCount);
            updateDeckView();
        }
        
        function clearDeck() {
            deck.clear();
            leader = null;
            applyFilters();
            updateDeckView();
        }

        function validateDeckColors() {
            if (!leader) return;
            const leaderColors = leader.color.split('/');
            for (const [cardId] of deck.entries()) {
                const card = allCards.find(c => c.id === cardId);
                if (!card.color.split('/').some(cc => leaderColors.includes(cc))) {
                    deck.delete(cardId);
                }
            }
        }

        function updateDeckView() {
            const counts = { CHARACTER: 0, EVENT: 0, STAGE: 0 };
            const typeOrder = { 'CHARACTER': 1, 'EVENT': 2, 'STAGE': 3 };
            const sortedDeck = Array.from(deck.keys()).map(id => allCards.find(c => c.id === id))
                .sort((a, b) => (typeOrder[a.cardType] - typeOrder[b.cardType]) || (a.cost ?? 0) - (b.cost ?? 0) || a.name.localeCompare(b.name));
            
            let deckGridHTML = '';
            sortedDeck.forEach(card => {
                const quantity = deck.get(card.id);
                deckGridHTML += `<div class="deck-grid-card" data-card-id="${card.id}" title="${card.name} (Cost: ${card.cost ?? 'N/A'})">
                    <img src="${getImagePath(card)}" loading="lazy" onerror="this.style.display='none';"><div class="card-quantity-badge">x${quantity}</div></div>`;
                counts[card.cardType] += quantity;
            });

            document.getElementById('leaderImage').innerHTML = leader ? `<img src="${getImagePath(leader)}" alt="${leader.name}">` : 'LEADER';
            document.getElementById('deckGrid').innerHTML = deckGridHTML;
            document.getElementById('characterCount').textContent = counts.CHARACTER;
            document.getElementById('eventCount').textContent = counts.EVENT;
            document.getElementById('stageCount').textContent = counts.STAGE;
            updateStatsView();
        }

        const memoizedFactorial = (() => {
            const cache = [1];
            return (n) => {
                if (n < 0) return NaN;
                if (n >= cache.length) {
                    for (let i = cache.length; i <= n; i++) {
                        cache[i] = i * cache[i - 1];
                    }
                }
                return cache[n];
            };
        })();
        
        const C = (n, k) => (k < 0 || k > n) ? 0 : memoizedFactorial(n) / (memoizedFactorial(k) * memoizedFactorial(n - k));
        const hypergeometric = (K, N, n, k) => C(K, k) * C(N - K, n - k) / C(N, n);
        const probAtLeastOne = (successes, popSize, draws) => {
            if (popSize <= 0 || draws <= 0 || successes <= 0 || draws > popSize) return 0;
            return 1 - hypergeometric(successes, popSize, draws, 0);
        };

        function updateStatsView() {
            const totalCount = Array.from(deck.values()).reduce((sum, count) => sum + count, 0);
            document.getElementById('deckCardCount').textContent = `Total Cards: ${totalCount} / ${DECK_SIZE}`;
            document.getElementById('deckCardCount').style.color = totalCount === DECK_SIZE ? '#27ae60' : (totalCount > DECK_SIZE ? '#e74c3c' : 'inherit');
            
            const costCurve = new Array(11).fill(0);
            deck.forEach((q, id) => {
                const card = allCards.find(c => c.id === id);
                if (card && card.cost != null && card.cardType !== 'STAGE') costCurve[Math.min(card.cost, 10)] += q;
            });
            const maxCount = Math.max(...costCurve, 1);
            document.getElementById('costCurve').innerHTML = costCurve.map((c, i) => `<div class="cost-bar" style="height: ${(c / maxCount) * 100}%;">${c > 0 ? `<span class="bar-count">${c}</span>` : ''}</div>`).join('');
            document.getElementById('costCurve-labels').innerHTML = costCurve.map((_, i) => `<div class="cost-label" style="flex: 1;">${i === 10 ? '10+' : i}</div>`).join('');

            let searcherHTML = '';
            const processedSearchers = new Set();
            deck.forEach((_, cardId) => {
                const card = allCards.find(c => c.id === cardId);
                if (!card || processedSearchers.has(card.id)) return;

                const searcherData = parseSearcherEffect(card.effect);
                if (searcherData) {
                    processedSearchers.add(card.id);
                    const targets = findSearcherTargets(searcherData.types);
                    if (targets.count === 0) return;

                    let tableHTML = '<thead><tr><th>Turn</th>' + Array.from({length: 10}, (_, i) => `<th>${i+1}</th>`).join('') + '</tr></thead>';
                    tableHTML += '<tbody><tr><td>Prob %</td>';
                    
                    for (let turn = 1; turn <= 10; turn++) {
                        const deckSizeAfterDraw = 50 - (5 + turn);
                        const prob = probAtLeastOne(targets.count, deckSizeAfterDraw, searcherData.look);
                        tableHTML += `<td>${(prob * 100).toFixed(0)}</td>`;
                    }
                    tableHTML += '</tr></tbody>';

                    searcherHTML += `<div class="searcher-item">
                        <div class="searcher-image"><img src="${getImagePath(card)}" alt="${card.name}"></div>
                        <div class="searcher-table-container">
                            <div class="searcher-info">Looks at <strong>${searcherData.look}</strong> for <strong>${targets.count}</strong> cards with type(s) <strong>{${searcherData.types.join(', ')}}</strong></div>
                            <table class="searcher-table">${tableHTML}</table>
                        </div>
                    </div>`;
                }
            });
            const analysisContainer = document.getElementById('searcherAnalysis');
            analysisContainer.innerHTML = searcherHTML ? `<h3>Searcher Analysis</h3>${searcherHTML}` : '';
        }

        function parseSearcherEffect(effectText) {
            const match = effectText.match(/look at (?:up to )?(\d+) cards from the top of your deck.*?reveal up to \d+.*?(?:\{([^}]+)\}|with a type including "([^"]+)")/i);
            if (!match) return null;
            const typesString = match[2] || match[3];
            return { look: parseInt(match[1]), types: typesString.split('/').map(t => t.trim().replace(/"/g, '')) };
        }

        function findSearcherTargets(targetTypes) {
            let count = 0;
            deck.forEach((quantity, cardId) => {
                const card = allCards.find(c => c.id === cardId);
                if (targetTypes.some(tt => card.type.split('/').includes(tt))) {
                    count += quantity;
                }
            });
            return { count };
        }
        
        function setupEventListeners() {
            document.getElementById('searchBar').addEventListener('input', applyFilters);
            document.getElementById('cardsContainer').addEventListener('click', handleCardClick);
            document.getElementById('clearDeckBtn').addEventListener('click', clearDeck);
            document.getElementById('deckListContainer').addEventListener('click', (e) => {
                const cardId = e.target.closest('.deck-grid-card')?.dataset.cardId;
                if (cardId) changeCardQuantity(cardId, -1);
            });

            const toggleFilter = (chip, collection) => {
                const value = chip.dataset[Object.keys(chip.dataset)[0]];
                collection.has(value) ? collection.delete(value) : collection.add(value);
                chip.classList.toggle('active'); applyFilters();
            };
            const togglePropertyFilter = (chip) => {
                const property = chip.dataset.property, state = propertyFilterStates.get(property);
                chip.classList.remove('active', 'inverse');
                if (state === 'has') { propertyFilterStates.set(property, 'no'); chip.classList.add('inverse'); }
                else if (state === 'no') { propertyFilterStates.delete(property); }
                else { propertyFilterStates.set(property, 'has'); chip.classList.add('active'); }
                applyFilters();
};

            document.querySelectorAll('.color-chip').forEach(c => c.addEventListener('click', () => toggleFilter(c, selectedColors)));
            document.querySelectorAll('.cost-chip').forEach(c => c.addEventListener('click', () => toggleFilter(c, selectedCosts)));
            document.querySelectorAll('.type-chip').forEach(c => c.addEventListener('click', () => toggleFilter(c, selectedTypes)));
            document.querySelectorAll('.counter-chip').forEach(c => c.addEventListener('click', () => toggleFilter(c, selectedCounters)));
            document.querySelectorAll('.property-chip').forEach(c => c.addEventListener('click', () => togglePropertyFilter(c)));
        }

        document.addEventListener('DOMContentLoaded', initializeDeckBuilder);
    </script>
</body>
</html>

